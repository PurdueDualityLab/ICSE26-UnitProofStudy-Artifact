
<html>
<head>
<title>os/sys/pt.h</title>
<link rel="stylesheet" type="text/css" href="../../viewer.css">
</head>

<body>
<div class="code">
<div id="1" class="line none">    1 /*</div><div id="2" class="line none">    2  * Copyright (c) 2004-2005, Swedish Institute of Computer Science.</div><div id="3" class="line none">    3  * All rights reserved.</div><div id="4" class="line none">    4  *</div><div id="5" class="line none">    5  * Redistribution and use in source and binary forms, with or without</div><div id="6" class="line none">    6  * modification, are permitted provided that the following conditions</div><div id="7" class="line none">    7  * are met:</div><div id="8" class="line none">    8  * 1. Redistributions of source code must retain the above copyright</div><div id="9" class="line none">    9  *    notice, this list of conditions and the following disclaimer.</div><div id="10" class="line none">   10  * 2. Redistributions in binary form must reproduce the above copyright</div><div id="11" class="line none">   11  *    notice, this list of conditions and the following disclaimer in the</div><div id="12" class="line none">   12  *    documentation and/or other materials provided with the distribution.</div><div id="13" class="line none">   13  * 3. Neither the name of the Institute nor the names of its contributors</div><div id="14" class="line none">   14  *    may be used to endorse or promote products derived from this software</div><div id="15" class="line none">   15  *    without specific prior written permission.</div><div id="16" class="line none">   16  *</div><div id="17" class="line none">   17  * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND</div><div id="18" class="line none">   18  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</div><div id="19" class="line none">   19  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</div><div id="20" class="line none">   20  * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE</div><div id="21" class="line none">   21  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</div><div id="22" class="line none">   22  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS</div><div id="23" class="line none">   23  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</div><div id="24" class="line none">   24  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</div><div id="25" class="line none">   25  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY</div><div id="26" class="line none">   26  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</div><div id="27" class="line none">   27  * SUCH DAMAGE.</div><div id="28" class="line none">   28  *</div><div id="29" class="line none">   29  * This file is part of the Contiki operating system.</div><div id="30" class="line none">   30  *</div><div id="31" class="line none">   31  * Author: Adam Dunkels &lt;adam@sics.se&gt;</div><div id="32" class="line none">   32  *</div><div id="33" class="line none">   33  */</div><div id="34" class="line none">   34 </div><div id="35" class="line none">   35 /**</div><div id="36" class="line none">   36  * \addtogroup threads</div><div id="37" class="line none">   37  * @{</div><div id="38" class="line none">   38  */</div><div id="39" class="line none">   39 </div><div id="40" class="line none">   40 /**</div><div id="41" class="line none">   41  * \defgroup pt Protothreads</div><div id="42" class="line none">   42  *</div><div id="43" class="line none">   43  * Protothreads are a type of lightweight stackless threads designed for</div><div id="44" class="line none">   44  * severly memory constrained systems such as deeply embedded systems or</div><div id="45" class="line none">   45  * sensor network nodes. Protothreads provides linear code execution for</div><div id="46" class="line none">   46  * event-driven systems implemented in C. Protothreads can be used with</div><div id="47" class="line none">   47  * or without an RTOS.</div><div id="48" class="line none">   48  *</div><div id="49" class="line none">   49  * Protothreads are a extremely lightweight, stackless type of threads</div><div id="50" class="line none">   50  * that provides a blocking context on top of an event-driven system,</div><div id="51" class="line none">   51  * without the overhead of per-thread stacks. The purpose of protothreads</div><div id="52" class="line none">   52  * is to implement sequential flow of control without complex state</div><div id="53" class="line none">   53  * machines or full multi-threading. Protothreads provides conditional</div><div id="54" class="line none">   54  * blocking inside C functions.</div><div id="55" class="line none">   55  *</div><div id="56" class="line none">   56  * The advantage of protothreads over a purely event-driven approach is</div><div id="57" class="line none">   57  * that protothreads provides a sequential code structure that allows for</div><div id="58" class="line none">   58  * blocking functions. In purely event-driven systems, blocking must be</div><div id="59" class="line none">   59  * implemented by manually breaking the function into two pieces - one</div><div id="60" class="line none">   60  * for the piece of code before the blocking call and one for the code</div><div id="61" class="line none">   61  * after the blocking call. This makes it hard to use control structures</div><div id="62" class="line none">   62  * such as if() conditionals and while() loops.</div><div id="63" class="line none">   63  *</div><div id="64" class="line none">   64  * The advantage of protothreads over ordinary threads is that a</div><div id="65" class="line none">   65  * protothread does not require a separate stack. In memory constrained</div><div id="66" class="line none">   66  * systems, the overhead of allocating multiple stacks can consume large</div><div id="67" class="line none">   67  * amounts of the available memory. In contrast, each protothread only</div><div id="68" class="line none">   68  * requires between two and twelve bytes of state, depending on the</div><div id="69" class="line none">   69  * architecture.</div><div id="70" class="line none">   70  *</div><div id="71" class="line none">   71  * \note Because protothreads do not save the stack context across a</div><div id="72" class="line none">   72  * blocking call, &lt;b&gt;local variables are not preserved when the</div><div id="73" class="line none">   73  * protothread blocks&lt;/b&gt;. This means that local variables should be used</div><div id="74" class="line none">   74  * with utmost care - &lt;b&gt;if in doubt, do not use local variables inside a</div><div id="75" class="line none">   75  * protothread!&lt;/b&gt;</div><div id="76" class="line none">   76  *</div><div id="77" class="line none">   77  *</div><div id="78" class="line none">   78  * Main features:</div><div id="79" class="line none">   79  *</div><div id="80" class="line none">   80  *  - No machine specific code - the protothreads library is pure C</div><div id="81" class="line none">   81  *</div><div id="82" class="line none">   82  *  - Does not use error-prone functions such as longjmp()</div><div id="83" class="line none">   83  *</div><div id="84" class="line none">   84  *  - Very small RAM overhead - only two bytes per protothread</div><div id="85" class="line none">   85  *</div><div id="86" class="line none">   86  *  - Can be used with or without an OS</div><div id="87" class="line none">   87  *</div><div id="88" class="line none">   88  *  - Provides blocking wait without full multi-threading or</div><div id="89" class="line none">   89  *    stack-switching</div><div id="90" class="line none">   90  *</div><div id="91" class="line none">   91  * Examples applications:</div><div id="92" class="line none">   92  *</div><div id="93" class="line none">   93  *  - Memory constrained systems</div><div id="94" class="line none">   94  *</div><div id="95" class="line none">   95  *  - Event-driven protocol stacks</div><div id="96" class="line none">   96  *</div><div id="97" class="line none">   97  *  - Deeply embedded systems</div><div id="98" class="line none">   98  *</div><div id="99" class="line none">   99  *  - Sensor network nodes</div><div id="100" class="line none">  100  *</div><div id="101" class="line none">  101  * The protothreads API consists of four basic operations:</div><div id="102" class="line none">  102  * initialization: PT_INIT(), execution: PT_BEGIN(), conditional</div><div id="103" class="line none">  103  * blocking: PT_WAIT_UNTIL() and exit: PT_END(). On top of these, two</div><div id="104" class="line none">  104  * convenience functions are built: reversed condition blocking:</div><div id="105" class="line none">  105  * PT_WAIT_WHILE() and protothread blocking: PT_WAIT_THREAD().</div><div id="106" class="line none">  106  *</div><div id="107" class="line none">  107  * \sa \ref pt "Protothreads API documentation"</div><div id="108" class="line none">  108  *</div><div id="109" class="line none">  109  * The protothreads library is released under a BSD-style license that</div><div id="110" class="line none">  110  * allows for both non-commercial and commercial usage. The only</div><div id="111" class="line none">  111  * requirement is that credit is given.</div><div id="112" class="line none">  112  *</div><div id="113" class="line none">  113  * \section authors Authors</div><div id="114" class="line none">  114  *</div><div id="115" class="line none">  115  * The protothreads library was written by Adam Dunkels &lt;adam@sics.se&gt;</div><div id="116" class="line none">  116  * with support from Oliver Schmidt &lt;ol.sc@web.de&gt;.</div><div id="117" class="line none">  117  *</div><div id="118" class="line none">  118  * \section pt-desc Protothreads</div><div id="119" class="line none">  119  *</div><div id="120" class="line none">  120  * Protothreads are a extremely lightweight, stackless threads that</div><div id="121" class="line none">  121  * provides a blocking context on top of an event-driven system, without</div><div id="122" class="line none">  122  * the overhead of per-thread stacks. The purpose of protothreads is to</div><div id="123" class="line none">  123  * implement sequential flow of control without using complex state</div><div id="124" class="line none">  124  * machines or full multi-threading. Protothreads provides conditional</div><div id="125" class="line none">  125  * blocking inside a C function.</div><div id="126" class="line none">  126  *</div><div id="127" class="line none">  127  * In memory constrained systems, such as deeply embedded systems,</div><div id="128" class="line none">  128  * traditional multi-threading may have a too large memory overhead. In</div><div id="129" class="line none">  129  * traditional multi-threading, each thread requires its own stack, that</div><div id="130" class="line none">  130  * typically is over-provisioned. The stacks may use large parts of the</div><div id="131" class="line none">  131  * available memory.</div><div id="132" class="line none">  132  *</div><div id="133" class="line none">  133  * The main advantage of protothreads over ordinary threads is that</div><div id="134" class="line none">  134  * protothreads are very lightweight: a protothread does not require its</div><div id="135" class="line none">  135  * own stack. Rather, all protothreads run on the same stack and context</div><div id="136" class="line none">  136  * switching is done by stack rewinding. This is advantageous in memory</div><div id="137" class="line none">  137  * constrained systems, where a stack for a thread might use a large part</div><div id="138" class="line none">  138  * of the available memory. A protothread only requires only two bytes of</div><div id="139" class="line none">  139  * memory per protothread. Moreover, protothreads are implemented in pure</div><div id="140" class="line none">  140  * C and do not require any machine-specific assembler code.</div><div id="141" class="line none">  141  *</div><div id="142" class="line none">  142  * A protothread runs within a single C function and cannot span over</div><div id="143" class="line none">  143  * other functions. A protothread may call normal C functions, but cannot</div><div id="144" class="line none">  144  * block inside a called function. Blocking inside nested function calls</div><div id="145" class="line none">  145  * is instead made by spawning a separate protothread for each</div><div id="146" class="line none">  146  * potentially blocking function. The advantage of this approach is that</div><div id="147" class="line none">  147  * blocking is explicit: the programmer knows exactly which functions</div><div id="148" class="line none">  148  * that block that which functions the never blocks.</div><div id="149" class="line none">  149  *</div><div id="150" class="line none">  150  * Protothreads are similar to asymmetric co-routines. The main</div><div id="151" class="line none">  151  * difference is that co-routines uses a separate stack for each</div><div id="152" class="line none">  152  * co-routine, whereas protothreads are stackless. The most similar</div><div id="153" class="line none">  153  * mechanism to protothreads are Python generators. These are also</div><div id="154" class="line none">  154  * stackless constructs, but have a different purpose. Protothreads</div><div id="155" class="line none">  155  * provides blocking contexts inside a C function, whereas Python</div><div id="156" class="line none">  156  * generators provide multiple exit points from a generator function.</div><div id="157" class="line none">  157  *</div><div id="158" class="line none">  158  * \section pt-autovars Local variables</div><div id="159" class="line none">  159  *</div><div id="160" class="line none">  160  * \note</div><div id="161" class="line none">  161  * Because protothreads do not save the stack context across a blocking</div><div id="162" class="line none">  162  * call, local variables are not preserved when the protothread</div><div id="163" class="line none">  163  * blocks. This means that local variables should be used with utmost</div><div id="164" class="line none">  164  * care - if in doubt, do not use local variables inside a protothread!</div><div id="165" class="line none">  165  *</div><div id="166" class="line none">  166  * \section pt-scheduling Scheduling</div><div id="167" class="line none">  167  *</div><div id="168" class="line none">  168  * A protothread is driven by repeated calls to the function in which the</div><div id="169" class="line none">  169  * protothread is running. Each time the function is called, the</div><div id="170" class="line none">  170  * protothread will run until it blocks or exits. Thus the scheduling of</div><div id="171" class="line none">  171  * protothreads is done by the application that uses protothreads.</div><div id="172" class="line none">  172  *</div><div id="173" class="line none">  173  * \section pt-impl Implementation</div><div id="174" class="line none">  174  *</div><div id="175" class="line none">  175  * Protothreads are implemented using \ref lc "local continuations". A</div><div id="176" class="line none">  176  * local continuation represents the current state of execution at a</div><div id="177" class="line none">  177  * particular place in the program, but does not provide any call history</div><div id="178" class="line none">  178  * or local variables. A local continuation can be set in a specific</div><div id="179" class="line none">  179  * function to capture the state of the function. After a local</div><div id="180" class="line none">  180  * continuation has been set can be resumed in order to restore the state</div><div id="181" class="line none">  181  * of the function at the point where the local continuation was set.</div><div id="182" class="line none">  182  *</div><div id="183" class="line none">  183  *</div><div id="184" class="line none">  184  * Local continuations can be implemented in a variety of ways:</div><div id="185" class="line none">  185  *</div><div id="186" class="line none">  186  * -# by using machine specific assembler code,</div><div id="187" class="line none">  187  * -# by using standard C constructs, or</div><div id="188" class="line none">  188  * -# by using compiler extensions.</div><div id="189" class="line none">  189  *</div><div id="190" class="line none">  190  * The first way works by saving and restoring the processor state,</div><div id="191" class="line none">  191  * except for stack pointers, and requires between 16 and 32 bytes of</div><div id="192" class="line none">  192  * memory per protothread. The exact amount of memory required depends on</div><div id="193" class="line none">  193  * the architecture.</div><div id="194" class="line none">  194  *</div><div id="195" class="line none">  195  * The standard C implementation requires only two bytes of state per</div><div id="196" class="line none">  196  * protothread and utilizes the C switch() statement in a non-obvious way</div><div id="197" class="line none">  197  * that is similar to Duff's device. This implementation does, however,</div><div id="198" class="line none">  198  * impose a slight restriction to the code that uses protothreads in that</div><div id="199" class="line none">  199  * the code cannot use switch() statements itself.</div><div id="200" class="line none">  200  *</div><div id="201" class="line none">  201  * Certain compilers has C extensions that can be used to implement</div><div id="202" class="line none">  202  * protothreads. GCC supports label pointers that can be used for this</div><div id="203" class="line none">  203  * purpose. With this implementation, protothreads require 4 bytes of RAM</div><div id="204" class="line none">  204  * per protothread.</div><div id="205" class="line none">  205  *</div><div id="206" class="line none">  206  * @{</div><div id="207" class="line none">  207  *</div><div id="208" class="line none">  208  * \file</div><div id="209" class="line none">  209  * Protothreads implementation.</div><div id="210" class="line none">  210  * \author</div><div id="211" class="line none">  211  * Adam Dunkels &lt;adam@sics.se&gt;</div><div id="212" class="line none">  212  */</div><div id="213" class="line none">  213 </div><div id="214" class="line none">  214 #ifndef <a href="pt.h.html#215">PT_H_</a></div><div id="215" class="line none">  215 #define <a href="pt.h.html#215">PT_H_</a></div><div id="216" class="line none">  216 </div><div id="217" class="line none">  217 #include "sys/lc.h"</div><div id="218" class="line none">  218 </div><div id="219" class="line none">  219 struct <a href="pt.h.html#219">pt</a> {</div><div id="220" class="line none">  220   <a href="lc-switch.h.html#63">lc_t</a> <a href="pt.h.html#220">lc</a>;</div><div id="221" class="line none">  221 };</div><div id="222" class="line none">  222 </div><div id="223" class="line none">  223 #define <a href="pt.h.html#223">PT_WAITING</a> 0</div><div id="224" class="line none">  224 #define <a href="pt.h.html#224">PT_YIELDED</a> 1</div><div id="225" class="line none">  225 #define <a href="pt.h.html#225">PT_EXITED</a>  2</div><div id="226" class="line none">  226 #define <a href="pt.h.html#226">PT_ENDED</a>   3</div><div id="227" class="line none">  227 </div><div id="228" class="line none">  228 /**</div><div id="229" class="line none">  229  * \name Initialization</div><div id="230" class="line none">  230  * @{</div><div id="231" class="line none">  231  */</div><div id="232" class="line none">  232 </div><div id="233" class="line none">  233 /**</div><div id="234" class="line none">  234  * Initialize a protothread.</div><div id="235" class="line none">  235  *</div><div id="236" class="line none">  236  * Initializes a protothread. Initialization must be done prior to</div><div id="237" class="line none">  237  * starting to execute the protothread.</div><div id="238" class="line none">  238  *</div><div id="239" class="line none">  239  * \param pt A pointer to the protothread control structure.</div><div id="240" class="line none">  240  *</div><div id="241" class="line none">  241  * \sa PT_SPAWN()</div><div id="242" class="line none">  242  *</div><div id="243" class="line none">  243  * \hideinitializer</div><div id="244" class="line none">  244  */</div><div id="245" class="line none">  245 #define <a href="pt.h.html#245">PT_INIT</a>(<a href="pt.h.html#219">pt</a>)   <a href="lc-switch.h.html#65">LC_INIT</a>((<a href="pt.h.html#219">pt</a>)-&gt;<a href="pt.h.html#220">lc</a>)</div><div id="246" class="line none">  246 </div><div id="247" class="line none">  247 /** @} */</div><div id="248" class="line none">  248 </div><div id="249" class="line none">  249 /**</div><div id="250" class="line none">  250  * \name Declaration and definition</div><div id="251" class="line none">  251  * @{</div><div id="252" class="line none">  252  */</div><div id="253" class="line none">  253 </div><div id="254" class="line none">  254 /**</div><div id="255" class="line none">  255  * Declaration of a protothread.</div><div id="256" class="line none">  256  *</div><div id="257" class="line none">  257  * This macro is used to declare a protothread. All protothreads must</div><div id="258" class="line none">  258  * be declared with this macro.</div><div id="259" class="line none">  259  *</div><div id="260" class="line none">  260  * \param name_args The name and arguments of the C function</div><div id="261" class="line none">  261  * implementing the protothread.</div><div id="262" class="line none">  262  *</div><div id="263" class="line none">  263  * \hideinitializer</div><div id="264" class="line none">  264  */</div><div id="265" class="line none">  265 #define <a href="pt.h.html#265">PT_THREAD</a>(name_args) char name_args</div><div id="266" class="line none">  266 </div><div id="267" class="line none">  267 /**</div><div id="268" class="line none">  268  * Declare the start of a protothread inside the C function</div><div id="269" class="line none">  269  * implementing the protothread.</div><div id="270" class="line none">  270  *</div><div id="271" class="line none">  271  * This macro is used to declare the starting point of a</div><div id="272" class="line none">  272  * protothread. It should be placed at the start of the function in</div><div id="273" class="line none">  273  * which the protothread runs. All C statements above the PT_BEGIN()</div><div id="274" class="line none">  274  * invokation will be executed each time the protothread is scheduled.</div><div id="275" class="line none">  275  *</div><div id="276" class="line none">  276  * \param pt A pointer to the protothread control structure.</div><div id="277" class="line none">  277  *</div><div id="278" class="line none">  278  * \hideinitializer</div><div id="279" class="line none">  279  */</div><div id="280" class="line none">  280 #define <a href="pt.h.html#280">PT_BEGIN</a>(<a href="pt.h.html#219">pt</a>) { char PT_YIELD_FLAG = 1; if (PT_YIELD_FLAG) {;} <a href="lc-switch.h.html#67">LC_RESUME</a>((<a href="pt.h.html#219">pt</a>)-&gt;<a href="pt.h.html#220">lc</a>)</div><div id="281" class="line none">  281 </div><div id="282" class="line none">  282 /**</div><div id="283" class="line none">  283  * Declare the end of a protothread.</div><div id="284" class="line none">  284  *</div><div id="285" class="line none">  285  * This macro is used for declaring that a protothread ends. It must</div><div id="286" class="line none">  286  * always be used together with a matching PT_BEGIN() macro.</div><div id="287" class="line none">  287  *</div><div id="288" class="line none">  288  * \param pt A pointer to the protothread control structure.</div><div id="289" class="line none">  289  *</div><div id="290" class="line none">  290  * \hideinitializer</div><div id="291" class="line none">  291  */</div><div id="292" class="line none">  292 #define <a href="pt.h.html#292">PT_END</a>(<a href="pt.h.html#219">pt</a>) <a href="lc-switch.h.html#71">LC_END</a>((<a href="pt.h.html#219">pt</a>)-&gt;<a href="pt.h.html#220">lc</a>); PT_YIELD_FLAG = 0; \</div><div id="293" class="line none">  293                    <a href="pt.h.html#245">PT_INIT</a>(<a href="pt.h.html#219">pt</a>); return <a href="pt.h.html#226">PT_ENDED</a>; }</div><div id="294" class="line none">  294 </div><div id="295" class="line none">  295 /** @} */</div><div id="296" class="line none">  296 </div><div id="297" class="line none">  297 /**</div><div id="298" class="line none">  298  * \name Blocked wait</div><div id="299" class="line none">  299  * @{</div><div id="300" class="line none">  300  */</div><div id="301" class="line none">  301 </div><div id="302" class="line none">  302 /**</div><div id="303" class="line none">  303  * Block and wait until condition is true.</div><div id="304" class="line none">  304  *</div><div id="305" class="line none">  305  * This macro blocks the protothread until the specified condition is</div><div id="306" class="line none">  306  * true.</div><div id="307" class="line none">  307  *</div><div id="308" class="line none">  308  * \param pt A pointer to the protothread control structure.</div><div id="309" class="line none">  309  * \param condition The condition.</div><div id="310" class="line none">  310  *</div><div id="311" class="line none">  311  * \hideinitializer</div><div id="312" class="line none">  312  */</div><div id="313" class="line none">  313 #define <a href="pt.h.html#313">PT_WAIT_UNTIL</a>(<a href="pt.h.html#219">pt</a>, condition)            \</div><div id="314" class="line none">  314   do {                                          \</div><div id="315" class="line none">  315     <a href="lc-switch.h.html#69">LC_SET</a>((<a href="pt.h.html#219">pt</a>)-&gt;<a href="pt.h.html#220">lc</a>);                           \</div><div id="316" class="line none">  316     if(!(condition)) {                          \</div><div id="317" class="line none">  317       return <a href="pt.h.html#223">PT_WAITING</a>;                        \</div><div id="318" class="line none">  318     }                                           \</div><div id="319" class="line none">  319   } while(0)</div><div id="320" class="line none">  320 </div><div id="321" class="line none">  321 /**</div><div id="322" class="line none">  322  * Block and wait while condition is true.</div><div id="323" class="line none">  323  *</div><div id="324" class="line none">  324  * This function blocks and waits while condition is true. See</div><div id="325" class="line none">  325  * PT_WAIT_UNTIL().</div><div id="326" class="line none">  326  *</div><div id="327" class="line none">  327  * \param pt A pointer to the protothread control structure.</div><div id="328" class="line none">  328  * \param cond The condition.</div><div id="329" class="line none">  329  *</div><div id="330" class="line none">  330  * \hideinitializer</div><div id="331" class="line none">  331  */</div><div id="332" class="line none">  332 #define <a href="pt.h.html#332">PT_WAIT_WHILE</a>(<a href="pt.h.html#219">pt</a>, cond)  <a href="pt.h.html#313">PT_WAIT_UNTIL</a>((<a href="pt.h.html#219">pt</a>), !(cond))</div><div id="333" class="line none">  333 </div><div id="334" class="line none">  334 /** @} */</div><div id="335" class="line none">  335 </div><div id="336" class="line none">  336 /**</div><div id="337" class="line none">  337  * \name Hierarchical protothreads</div><div id="338" class="line none">  338  * @{</div><div id="339" class="line none">  339  */</div><div id="340" class="line none">  340 </div><div id="341" class="line none">  341 /**</div><div id="342" class="line none">  342  * Block and wait until a child protothread completes.</div><div id="343" class="line none">  343  *</div><div id="344" class="line none">  344  * This macro schedules a child protothread. The current protothread</div><div id="345" class="line none">  345  * will block until the child protothread completes.</div><div id="346" class="line none">  346  *</div><div id="347" class="line none">  347  * \note The child protothread must be manually initialized with the</div><div id="348" class="line none">  348  * PT_INIT() function before this function is used.</div><div id="349" class="line none">  349  *</div><div id="350" class="line none">  350  * \param pt A pointer to the protothread control structure.</div><div id="351" class="line none">  351  * \param thread The child protothread with arguments</div><div id="352" class="line none">  352  *</div><div id="353" class="line none">  353  * \sa PT_SPAWN()</div><div id="354" class="line none">  354  *</div><div id="355" class="line none">  355  * \hideinitializer</div><div id="356" class="line none">  356  */</div><div id="357" class="line none">  357 #define <a href="pt.h.html#357">PT_WAIT_THREAD</a>(<a href="pt.h.html#219">pt</a>, thread) <a href="pt.h.html#332">PT_WAIT_WHILE</a>((<a href="pt.h.html#219">pt</a>), <a href="pt.h.html#436">PT_SCHEDULE</a>(thread))</div><div id="358" class="line none">  358 </div><div id="359" class="line none">  359 /**</div><div id="360" class="line none">  360  * Spawn a child protothread and wait until it exits.</div><div id="361" class="line none">  361  *</div><div id="362" class="line none">  362  * This macro spawns a child protothread and waits until it exits. The</div><div id="363" class="line none">  363  * macro can only be used within a protothread.</div><div id="364" class="line none">  364  *</div><div id="365" class="line none">  365  * \param pt A pointer to the protothread control structure.</div><div id="366" class="line none">  366  * \param child A pointer to the child protothread's control structure.</div><div id="367" class="line none">  367  * \param thread The child protothread with arguments</div><div id="368" class="line none">  368  *</div><div id="369" class="line none">  369  * \hideinitializer</div><div id="370" class="line none">  370  */</div><div id="371" class="line none">  371 #define <a href="pt.h.html#371">PT_SPAWN</a>(<a href="pt.h.html#219">pt</a>, child, thread)             \</div><div id="372" class="line none">  372   do {                                          \</div><div id="373" class="line none">  373     <a href="pt.h.html#245">PT_INIT</a>((child));                           \</div><div id="374" class="line none">  374     <a href="pt.h.html#357">PT_WAIT_THREAD</a>((<a href="pt.h.html#219">pt</a>), (thread));             \</div><div id="375" class="line none">  375   } while(0)</div><div id="376" class="line none">  376 </div><div id="377" class="line none">  377 /** @} */</div><div id="378" class="line none">  378 </div><div id="379" class="line none">  379 /**</div><div id="380" class="line none">  380  * \name Exiting and restarting</div><div id="381" class="line none">  381  * @{</div><div id="382" class="line none">  382  */</div><div id="383" class="line none">  383 </div><div id="384" class="line none">  384 /**</div><div id="385" class="line none">  385  * Restart the protothread.</div><div id="386" class="line none">  386  *</div><div id="387" class="line none">  387  * This macro will block and cause the running protothread to restart</div><div id="388" class="line none">  388  * its execution at the place of the PT_BEGIN() call.</div><div id="389" class="line none">  389  *</div><div id="390" class="line none">  390  * \param pt A pointer to the protothread control structure.</div><div id="391" class="line none">  391  *</div><div id="392" class="line none">  392  * \hideinitializer</div><div id="393" class="line none">  393  */</div><div id="394" class="line none">  394 #define <a href="pt.h.html#394">PT_RESTART</a>(<a href="pt.h.html#219">pt</a>)                          \</div><div id="395" class="line none">  395   do {                                          \</div><div id="396" class="line none">  396     <a href="pt.h.html#245">PT_INIT</a>(<a href="pt.h.html#219">pt</a>);                                \</div><div id="397" class="line none">  397     return <a href="pt.h.html#223">PT_WAITING</a>;                  \</div><div id="398" class="line none">  398   } while(0)</div><div id="399" class="line none">  399 </div><div id="400" class="line none">  400 /**</div><div id="401" class="line none">  401  * Exit the protothread.</div><div id="402" class="line none">  402  *</div><div id="403" class="line none">  403  * This macro causes the protothread to exit. If the protothread was</div><div id="404" class="line none">  404  * spawned by another protothread, the parent protothread will become</div><div id="405" class="line none">  405  * unblocked and can continue to run.</div><div id="406" class="line none">  406  *</div><div id="407" class="line none">  407  * \param pt A pointer to the protothread control structure.</div><div id="408" class="line none">  408  *</div><div id="409" class="line none">  409  * \hideinitializer</div><div id="410" class="line none">  410  */</div><div id="411" class="line none">  411 #define <a href="pt.h.html#411">PT_EXIT</a>(<a href="pt.h.html#219">pt</a>)                             \</div><div id="412" class="line none">  412   do {                                          \</div><div id="413" class="line none">  413     <a href="pt.h.html#245">PT_INIT</a>(<a href="pt.h.html#219">pt</a>);                                \</div><div id="414" class="line none">  414     return <a href="pt.h.html#225">PT_EXITED</a>;                   \</div><div id="415" class="line none">  415   } while(0)</div><div id="416" class="line none">  416 </div><div id="417" class="line none">  417 /** @} */</div><div id="418" class="line none">  418 </div><div id="419" class="line none">  419 /**</div><div id="420" class="line none">  420  * \name Calling a protothread</div><div id="421" class="line none">  421  * @{</div><div id="422" class="line none">  422  */</div><div id="423" class="line none">  423 </div><div id="424" class="line none">  424 /**</div><div id="425" class="line none">  425  * Schedule a protothread.</div><div id="426" class="line none">  426  *</div><div id="427" class="line none">  427  * This function schedules a protothread. The return value of the</div><div id="428" class="line none">  428  * function is non-zero if the protothread is running or zero if the</div><div id="429" class="line none">  429  * protothread has exited.</div><div id="430" class="line none">  430  *</div><div id="431" class="line none">  431  * \param f The call to the C function implementing the protothread to</div><div id="432" class="line none">  432  * be scheduled</div><div id="433" class="line none">  433  *</div><div id="434" class="line none">  434  * \hideinitializer</div><div id="435" class="line none">  435  */</div><div id="436" class="line none">  436 #define <a href="pt.h.html#436">PT_SCHEDULE</a>(<a href="ctimer.h.html#67">f</a>) ((<a href="ctimer.h.html#67">f</a>) &lt; <a href="pt.h.html#225">PT_EXITED</a>)</div><div id="437" class="line none">  437 </div><div id="438" class="line none">  438 /** @} */</div><div id="439" class="line none">  439 </div><div id="440" class="line none">  440 /**</div><div id="441" class="line none">  441  * \name Yielding from a protothread</div><div id="442" class="line none">  442  * @{</div><div id="443" class="line none">  443  */</div><div id="444" class="line none">  444 </div><div id="445" class="line none">  445 /**</div><div id="446" class="line none">  446  * Yield from the current protothread.</div><div id="447" class="line none">  447  *</div><div id="448" class="line none">  448  * This function will yield the protothread, thereby allowing other</div><div id="449" class="line none">  449  * processing to take place in the system.</div><div id="450" class="line none">  450  *</div><div id="451" class="line none">  451  * \param pt A pointer to the protothread control structure.</div><div id="452" class="line none">  452  *</div><div id="453" class="line none">  453  * \hideinitializer</div><div id="454" class="line none">  454  */</div><div id="455" class="line none">  455 #define <a href="pt.h.html#455">PT_YIELD</a>(<a href="pt.h.html#219">pt</a>)                            \</div><div id="456" class="line none">  456   do {                                          \</div><div id="457" class="line none">  457     PT_YIELD_FLAG = 0;                          \</div><div id="458" class="line none">  458     <a href="lc-switch.h.html#69">LC_SET</a>((<a href="pt.h.html#219">pt</a>)-&gt;<a href="pt.h.html#220">lc</a>);                           \</div><div id="459" class="line none">  459     if(PT_YIELD_FLAG == 0) {                    \</div><div id="460" class="line none">  460       return <a href="pt.h.html#224">PT_YIELDED</a>;                        \</div><div id="461" class="line none">  461     }                                           \</div><div id="462" class="line none">  462   } while(0)</div><div id="463" class="line none">  463 </div><div id="464" class="line none">  464 /**</div><div id="465" class="line none">  465  * \brief      Yield from the protothread until a condition occurs.</div><div id="466" class="line none">  466  * \param pt   A pointer to the protothread control structure.</div><div id="467" class="line none">  467  * \param cond The condition.</div><div id="468" class="line none">  468  *</div><div id="469" class="line none">  469  *             This function will yield the protothread, until the</div><div id="470" class="line none">  470  *             specified condition evaluates to true.</div><div id="471" class="line none">  471  *</div><div id="472" class="line none">  472  *</div><div id="473" class="line none">  473  * \hideinitializer</div><div id="474" class="line none">  474  */</div><div id="475" class="line none">  475 #define <a href="pt.h.html#475">PT_YIELD_UNTIL</a>(<a href="pt.h.html#219">pt</a>, cond)                \</div><div id="476" class="line none">  476   do {                                          \</div><div id="477" class="line none">  477     PT_YIELD_FLAG = 0;                          \</div><div id="478" class="line none">  478     <a href="lc-switch.h.html#69">LC_SET</a>((<a href="pt.h.html#219">pt</a>)-&gt;<a href="pt.h.html#220">lc</a>);                           \</div><div id="479" class="line none">  479     if((PT_YIELD_FLAG == 0) || !(cond)) {       \</div><div id="480" class="line none">  480       return <a href="pt.h.html#224">PT_YIELDED</a>;                        \</div><div id="481" class="line none">  481     }                                           \</div><div id="482" class="line none">  482   } while(0)</div><div id="483" class="line none">  483 </div><div id="484" class="line none">  484 /** @} */</div><div id="485" class="line none">  485 </div><div id="486" class="line none">  486 #endif /* PT_H_ */</div><div id="487" class="line none">  487 </div><div id="488" class="line none">  488 /**</div><div id="489" class="line none">  489  * @}</div><div id="490" class="line none">  490  * @}</div><div id="491" class="line none">  491  */</div>
</div>
</body>
</html>
